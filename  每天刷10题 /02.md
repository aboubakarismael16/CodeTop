[2022-01-21](#2022-01-21)
1. ✅[19. Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
2. ✅[8. String to Integer (atoi)](#8-string-to-integer-atoi)
3. ✅[2. Add Two Numbers](#2-add-two-numbers)
4. ✅[144. Binary Tree Preorder Traversal](#144-binary-tree-preorder-traversal)
5. ✅[148. Sort List](#148-sort-list)

## [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)
```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{-1, head}
    slow, fast := dummy, dummy

    for i := 0; i <= n; i++ {
        fast = fast.Next
    }

    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }

    slow.Next = slow.Next.Next

    return dummy.Next
}
```
Accepted
- 208/208 cases passed (0 ms)
- Your runtime beats 100 % of golang submissions
- Your memory usage beats 100 % of golang submissions (2.2 MB)

## [8. String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/)
```go
func myAtoi(s string) int {
    var (
        ans int64 = 0
        sign int64 = 1
    )
    start := false

    for _,c := range s {
        if c <= '9' && c >= '0' {
            if !start {
                start = true
            }

            ans = ans *10 + int64(c)-int64('0')
            if ans * sign > math.MaxInt32 {
                return math.MaxInt32
            } else if ans*sign < math.MinInt32 {
                return math.MinInt32
            }
        } else if !start && c == '+' {
            start = true
        } else if !start && c == '-' {
            start = true
            sign = -1
        } else if c == ' ' {
            if !start {
                continue 
            } else {
                break
            }
        } else {
            break
        }
    }

    return int(ans*sign)
}
```
Accepted
- 1082/1082 cases passed (4 ms)
- Your runtime beats 54.43 % of golang submissions
- Your memory usage beats 100 % of golang submissions (2.2 MB)

## [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)
```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    curry := 0
    dummy := &ListNode{}
    cur := dummy

    for l1 != nil || l2 != nil {
        sum := curry

        if l1 != nil {
            sum += l1.Val
            l1 =l1.Next
        }
        if l2 != nil {
            sum += l2.Val
            l2 = l2.Next
        }

        curry = sum / 10
        cur.Next = &ListNode{Val: sum % 10}
        cur = cur.Next
    }

    if curry != 0 {
        cur.Next = &ListNode{Val: curry}
    }

    return dummy.Next
}
```
## [144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)

```go
func preorderTraversal(root *TreeNode) []int {
    if root == nil {
        return nil
    }

    preOrder := make([]int,0 )
    preOrder = append(preOrder, root.Val)
    preOrder = append(preOrder, preorderTraversal(root.Left)...)
    preOrder = append(preOrder, preorderTraversal(root.Right)...)

    return preOrder
}
```
Accepted
- 69/69 cases passed (0 ms)
- Your runtime beats 100 % of golang submissions
- Your memory usage beats 17.52 % of golang submissions (2 MB)

## [148. Sort List](https://leetcode.com/problems/sort-list/)
```go
func sortList(head *ListNode) *ListNode {
    dummy := &ListNode{}
    dummy.Next = head
    
    p := head
    n := 0
    for p != nil {
        p = p.Next
        n++
    }

    for i := 1; i < n; i = i * 2 { 
        cur := dummy         
        for j := 0; j + i < n; j = j + 2*i {
            l, r := 0, 0           
            left, right := cur.Next, cur.Next 
            for k := 0; k < i; k++ {          
                right = right.Next
            }

            for l < i && r < i && right != nil {
                if left.Val <= right.Val {
                    cur.Next = left
                    cur = cur.Next
                    left = left.Next
                    l += 1
                }else{
                    cur.Next = right
                    cur = cur.Next
                    right = right.Next
                    r += 1
                }
            }
            for l < i {
                cur.Next = left
                cur = cur.Next
                left = left.Next
                l += 1
            }
            for r < i && right != nil { 
                cur.Next = right
                cur = cur.Next
                right = right.Next
                r += 1
            }
            cur.Next = right
        } 
    }       
    return dummy.Next
}
```

Accepted
- 28/28 cases passed (28 ms)
- Your runtime beats 77.87 % of golang submissions
- Your memory usage beats 45.95 % of golang submissions (7.2 MB)
